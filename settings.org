#+OPTIONS: toc

* Context

  This is an ~org-babel~ Emacs configuration file, currently rolling on the following setting:

  - Mac OS 26.0.1
  - Emacs 30.1

  In order to load this file, include the following lines in your ~.emacs~:

#+BEGIN_SRC emacs-lisp :tangle no
  (require 'org)
  (org-babel-load-file "~/emacs/settings.org") ; or wherever you have it
#+END_SRC

* Emacs-Mac specific config

  These configs applies to the Emacs Mac port only.

** Open in full screen by default

  It appears that the fullscreen doesn't work natively in Mac OS, so we need to explicitly do it
  here.

#+BEGIN_SRC emacs-lisp
  (set-frame-parameter nil 'fullscreen 'fullscreen)
#+END_SRC

* Backups

  Lifted from:
  https://stackoverflow.com/questions/151945/how-do-i-control-how-emacs-makes-backup-files

  Avoid saving the back-up on the same directory as the original file.  This is useful for Helm, for
  example, which takes all files on the templates directory, mixing in back-ups as well.

#+BEGIN_SRC emacs-lisp
  (defconst emacs-tmp-dir (expand-file-name (format "emacs%d" (user-uid)) temporary-file-directory))
  (setq backup-directory-alist
        `((".*" . ,emacs-tmp-dir)))
#+END_SRC

  Safest way to create back-ups is by copying (rather than renaming the original):

#+BEGIN_SRC emacs-lisp
  (setq backup-by-copying t)
#+END_SRC

  Also, auto-save files can mess up some stuff (for example, Uvicorn auto-reload):

#+BEGIN_SRC emacs-lisp
  (setq auto-save-file-name-transforms
        `((".*" ,emacs-tmp-dir t)))
  (setq auto-save-list-file-prefix
        emacs-tmp-dir)
#+END_SRC

  Finally, even after all this, Emacs _still_ creates so-called _lock files_, which are symlinks.
  Since this is really only useful for multiple users editing the same file concurrently, which
  never happens to me, we can disable this.

#+BEGIN_SRC emacs-lisp
  (setq create-lockfiles nil)
#+END_SRC

* Straight

  Straight is a convenient package manager.  Unfortunately, I have relied too much on manually
  installing packages, so not all packages are here.  Installing Emacs in a new environment is
  pretty much a trial-and-error process for me.  But I'm getting there.

#+BEGIN_SRC emacs-lisp
  (defvar bootstrap-version)

  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 6))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
#+END_SRC

* Things at Point

  Interpreting and visiting things (mostly files and URLs) at ~point~.  I'll bind to a key
  combination this later on.

#+BEGIN_SRC emacs-lisp
  (require 'thing-cmds)
#+END_SRC

  The source code for this package, lifted from somewhere I can't remember, can be found alongside
  this settings file.  I should look into a package for this sometime.  ðŸ˜…

* eshell

  Shell emulation:

#+BEGIN_SRC emacs-lisp
(require 'eshell)
(require 'em-prompt)
#+END_SRC

* Custom functions

** Utilities

#+BEGIN_SRC emacs-lisp
  (defun ensure-list (thing)
    (if (atom thing) (list thing) thing))
#+END_SRC

** Killing space around ~point~

   ~just-one-space~ is very useful, but I also like it to kill newlines:

#+BEGIN_SRC emacs-lisp
  (defun ruaraujo/just-one-space ()
    (interactive)
    (just-one-space -1))
#+END_SRC

** Moving to beginning of line

   Usually I want to move to the beginning of the indentation, but sometimes also to the beginning
   of the line, so this little utility lets me toggle between the two.

#+BEGIN_SRC emacs-lisp
  (defun ruaraujo/beginning-of-line ()
    (interactive)
    (let ((old-point (point)))
      (back-to-indentation)
      (when (= (point) old-point)
        (beginning-of-line))))
#+END_SRC

* Get rid of clutter

  I like my Emacs lean, so let's remove the toolbar, menu, and scrollbar:

#+BEGIN_SRC emacs-lisp
  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (scroll-bar-mode -1)
#+END_SRC

* IDO

  Helper for finding files and buffers:

#+BEGIN_SRC emacs-lisp
  (require 'ido)
  (ido-mode 1)
#+END_SRC

* Org

  The default Org TODO status tags just don't cut it.  I need some more:

#+BEGIN_SRC emacs-lisp
  (setq org-todo-keywords
        '((sequence "TODO"      ; it must be done, and depends on me to get it done 
                    "FEEDBACK"  ; waiting for feedback from someone
                    "BLOCKED"   ; needs to be done, but progress is blocked by some condition
                    "|"
                    "DONE"      ; well, done
                    "DELEGATED" ; someone else will do it
                    "POSTPONED" ; will be done at a later time
                    "CANCELLED" ; no need to do it anymore
                    )))
  (setq org-todo-keyword-faces
        '(( "TODO"      . (:foreground "red" :weight bold))
          ( "FEEDBACK"  . (:foreground "orange" :weight bold))
          ( "BLOCKED"   . (:foreground "red" :weight bold))
          ( "DONE"      . (:foreground "dark green" :weight bold))
          ( "DELEGATED" . (:foreground "blue" :weight bold))
          ( "POSTPONED" . (:foreground "gray" :weight bold))
          ( "CANCELLED" . (:foreground "gray" :weight bold))
          ))
#+END_SRC

  Faster cycling through TODO status (`C-c t` is way too much of a nuisance).

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook
            (lambda ()
              (local-set-key (kbd "M-p") 'org-todo)))
#+END_SRC


#+BEGIN_SRC emacs-lisp
  (setq org-image-actual-width nil)

  (org-babel-do-load-languages
   'org-babel-load-languages
   '((ditaa . t)))

  (setq ob-ditaa-jar-path "/usr/local/Cellar/ditaa/0.11.0_1/bin/")

  (setcar org-emphasis-regexp-components " \t('\"{[:alpha:]")
  (setcar (nthcdr 1 org-emphasis-regexp-components) "[:alpha:]- \t.,:!?;'\")}\\")
  (org-set-emph-re 'org-emphasis-regexp-components org-emphasis-regexp-components)
#+END_SRC

* Par Edit

  Smart parenthesis, quotes, brackets, etc.

#+BEGIN_SRC emacs-lisp
  (require 'paredit)
  (autoload 'enable-paredit-mode "paredit" t)
#+END_SRC

* Multiple Cursors

  This neat utility allows performing the same command over several cursors simultaneously.  Super
  useful.

#+BEGIN_SRC emacs-lisp
  (require 'multiple-cursors)
  (global-set-key (kbd "C-c RET") 'mc/edit-lines)
#+END_SRC

* Emacs Lisp

  Use ~paredit~ in ~emacs-lisp-mode~, and a couple of useful keybindings for that mode.

#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-lisp-mode-hook
            (lambda ()
              (paredit-mode 1)
              (local-set-key [(control c) %] 'raise-sexp)
              (local-set-key [(control return)] 'mark-enclosing-list)))
#+END_SRC

* Lisp

#+BEGIN_SRC emacs-lisp
  (setq inferior-lisp-program "sbcl")

  (org-babel-do-load-languages
   'org-babel-load-languages
   '((lisp . t)))

  (add-hook 'lisp-mode-hook
            (lambda ()
              (paredit-mode 1)
              (local-set-key [(control c) %] 'raise-sexp)
              (local-set-key [(control return)] 'mark-enclosing-list)))

#+END_SRC

* Flycheck

  This package offers cross-language support for spelling and syntax checking.

#+BEGIN_SRC emacs-lisp
  (require 'flycheck)
  (exec-path-from-shell-initialize)
#+END_SRC

* Git grep

  ~vc-git-grep~ is powerful, but has a couple of shortcomings (e.g., it's not
  recursive by default).  Let's load ~git-grep~ instead:

#+BEGIN_SRC emacs-lisp
  (load "~/emacs-settings/git-grep")
#+END_SRC

* Magit

  Magit is a Git porcelain for Emacs that allows performing the most usual Git
  operations with a nice and intuitive interface.

#+BEGIN_SRC emacs-lisp
  (global-set-key [(control c) (g)] 'magit-status)
#+END_SRC

  I like to easily ~ediff~ my changes wrt to ~origin/main~, so let's setup a keybinding for that:

#+BEGIN_SRC emacs-lisp
  (require 'magit)

  (defun ruaraujo/magit-ediff-head-trunk (file)
    ;; lifted and adapted from `magit-ediff-show-working-tree'
    (interactive
     (list (magit-read-file-choice "Show changes in file"
                                   (magit-changed-files "origin/main..HEAD")
                                   "No changed files")))
    (magit-with-toplevel
      (let ((conf (current-window-configuration))
            (bufA (magit-get-revision-buffer "origin/trunk" file))
            (bufB (get-file-buffer file)))
        (ediff-buffers
         (or bufA (magit-find-file-noselect "origin/trunk" file))
         (or bufB (find-file-noselect file))
         `((lambda ()
             (setq-local
              ediff-quit-hook
              (lambda ()
                ,@(unless bufA '((ediff-kill-buffer-carefully ediff-buffer-A)))
                ,@(unless bufB '((ediff-kill-buffer-carefully ediff-buffer-B)))
                (let ((magit-ediff-previous-winconf ,conf))
                  (run-hooks 'magit-ediff-quit-hook))))))
         'ediff-buffers))))

  (global-set-key (kbd "<f12>") 'ruaraujo/magit-ediff-head-trunk)
#+END_SRC

  We use a lot of pre-commit hooks which output ANSI colour codes, so let's make Magit handle them:

#+BEGIN_SRC emacs-lisp
  (setq magit-process-finish-apply-ansi-colors t)
#+END_SRC

* Finding files

#+BEGIN_SRC emacs-lisp
  (require 'find-file-in-project)
  (setq ffip-use-rust-fd t)
#+END_SRC

* Global keybindings

#+BEGIN_SRC emacs-lisp
  (global-set-key [(control a)] 'ruaraujo/beginning-of-line)
  (global-set-key [(control tab)] 'hippie-expand)
  (global-set-key (kbd "M-SPC") 'ruaraujo/just-one-space)
  (global-set-key (kbd "C-;") 'comment-region)
  (global-set-key (kbd "C-M-;") 'uncomment-region)
  (global-set-key (kbd "C-x p") 'find-file-at-point)
  (global-set-key (kbd "s-<return>") 'git-grep)
  (global-set-key (kbd "M-+") 'text-scale-increase)
  (global-set-key (kbd "M-_") 'text-scale-decrease)
#+END_SRC

  The ~C-<up>~ and ~C-<down>~ keybindings are usually bound to paragraph
  navigation commands, but Mac OS really likes those key combos, so let's use
  the Command key instead:

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "s-<down>") 'forward-paragraph)
  (global-set-key (kbd "s-<up>") 'backward-paragraph)
#+END_SRC

  Paragraph filling annoyingly moves point to the beggining of
  the paragraph.  That won't do.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-q")
                  (lambda ()
                    (interactive)
                    (save-excursion (fill-paragraph))))
#+END_SRC

  I use ~revert-buffer~ 99% of the times to refresh some log file, and I find it
  annoying that I have to confirm every time.  So, let's bind a no-confirmation
  ~revert-buffer~ call to a slightly non-fat fingering prone key combo (~s-R~).

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "s-R") (lambda () (interactive) (revert-buffer nil t)))
#+END_SRC

  ~s-k~ is bound by default to ~kill-this-buffer~, no questions asked.  This is
  way too aggressive for my fat-fingering inclinations, so I'll switch it with
  ~s-M-k~:

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "s-k") nil)
  (global-set-key (kbd "s-M-k") 'kill-this-buffer)
#+END_SRC

  ~s-q~ kills Emacs by default. Again, not a good idea for me.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "s-q") nil)
#+END_SRC

* Options

  Deactivate line truncation by default:

#+BEGIN_SRC emacs-lisp
  ;; FIXME this is actually not working as expected
  (set-default 'truncate-lines nil)
  (set-default 'truncate-partial-width-windows nil)
  (add-hook 'org-mode-hook
            (lambda () 
              (setq truncate-lines nil)
              (setq truncate-partial-width-windows nil)))
#+END_SRC

  Visualise expressions in parentheses (this is more useful for Lisp programs,
  but meh, I guess old habits die hard):

#+BEGIN_SRC emacs-lisp
  (require 'paren)
  (show-paren-mode 1)
  (setq show-paren-style 'expression)
#+END_SRC

  Customise ~kill-line~ to kill the whole line, including the ending newline,
  when ~point~ is at the beginning of a line:

#+BEGIN_SRC emacs-lisp
  (setq kill-whole-line t)
#+END_SRC

  Tabs are for suckers; always use space indentation:

#+BEGIN_SRC emacs-lisp
  (customize-set-variable 'indent-tabs-mode nil)
#+END_SRC

  ... although there are plenty of suckers around, so let's set the tab width:

#+BEGIN_SRC emacs-lisp
  (setq-default tab-width 4)
#+END_SRC

  This by itself doesn't do much, because most modes set their own tab width.  For example, in
  ~python-mode~, the default is 8, which is ridiculous.  Let's fix it:

#+BEGIN_SRC emacs-lisp
  (add-hook 'python-ts-mode-hook (lambda () (setq tab-width 4)))
  (add-hook 'yaml-mode-hook (lambda () (setq tab-width 2)))
  (add-hook 'js-mode-hook (lambda () (setq tab-width 2)))
  (add-hook 'json-mode-hook (lambda () (setq tab-width 2)))
  (add-hook 'typescript-mode-hook (lambda () (setq tab-width 2)))
  (add-hook 'emacs-lisp-mode-hook (lambda () (setq tab-width 2)))
#+END_SRC

    I'm an old-fashioned guy: 100 columns is enough for line-wrapping.

#+BEGIN_SRC emacs-lisp
    (set-default 'fill-column 100)
#+END_SRC

  Open in full height, reasonable width (lifted from [[https://stackoverflow.com/questions/17362999/setting-both-fullheight-and-width-in-emacs-on-os-x][StackOverflow]]):

#+BEGIN_SRC emacs-lisp
  (defun get-default-height ()
         (/ (- (display-pixel-height) 120)
            (frame-char-height)))

  (add-to-list 'default-frame-alist '(width . 240))
  (add-to-list 'default-frame-alist (cons 'height (get-default-height)))
#+END_SRC

  ~ediff~ vertically by default:

#+BEGIN_SRC emacs-lisp
  (setq ediff-split-window-function 'split-window-horizontally)
#+END_SRC

  And make it open the control panel in the same frame:

#+BEGIN_SRC emacs-lisp
  (set-variable 'ediff-window-setup-function 'ediff-setup-windows-plain)
#+END_SRC

* Theme

#+BEGIN_SRC emacs-lisp
  (use-package timu-macos-theme :ensure t)
  (customize-set-variable 'timu-macos-flavour "light")

  (customize-set-variable 'timu-macos-scale-org-document-title t)
  (customize-set-variable 'timu-macos-scale-org-document-info t)
  (customize-set-variable 'timu-macos-scale-org-level-1 t)
  (customize-set-variable 'timu-macos-scale-org-level-2 t)
  (customize-set-variable 'timu-macos-scale-org-level-3 t)

  (customize-set-variable 'timu-macos-org-intense-colors t)

  (load-theme 'timu-macos t)

  (add-to-list 'default-frame-alist '(font . "SF Mono-13"))

  (use-package timu-line :ensure t :config (timu-line-mode 1))
#+END_SRC

* Indent bars

  A more optimised and better looking indent highlighter.

#+BEGIN_SRC emacs-lisp
  (use-package indent-bars
    :ensure t
    :config
    (setopt
     ;; HACK! I'm using an Emacs port that supports stipples only
     ;; partially, making it impossible to set the bar colour
     indent-bars-prefer-character t
     indent-bars-pattern "."
     indent-bars-width-frac 0.5
     indent-bars-pad-frac 0.25
     indent-bars-color-by-depth nil
     indent-bars-color '(highlight :blend 0.1)
     indent-bars-highlight-current-depth '(:face default :blend 0.2))
    :custom
    (indent-bars-no-descend-lists t)   ; no extra bars in continued func arg lists
    (indent-bars-treesit-support t)
    (indent-bars-treesit-ignore-blank-lines-types '("module"))
    (indent-bars-treesit-scope '((python function_definition class_definition for_statement
  	                                   if_statement with_statement while_statement)))
    (indent-bars-treesit-wrap '((python argument_list parameters
  				                      list list_comprehension
  				                      dictionary dictionary_comprehension
  				                      parenthesized_expression subscript)))
    :hook ((python-ts-mode yaml-mode) . indent-bars-mode))

#+END_SRC

  This enables ~tree-sitter~ integration in ~indent-bars~, which makes it look
  nicer.

#+BEGIN_SRC emacs-lisp
  (add-hook 'python-ts-mode-hook (lambda () (treesit-parser-create 'python)))
#+END_SRC

* Python with treesitter and eglot

  I used an Elpy-based setup, but it was frankly too cumbersome and outdated to maintain.  The
  treesitter+eglot setup is more modern, faster, and generally better (for example, find definition
  is much more accurate).

#+BEGIN_SRC emacs-lisp
  (setq major-mode-remap-alist
        '((python-mode . python-ts-mode)))
#+END_SRC

  +Ensure that ~eglot~ starts when a Python buffer is open.+

  We should explicitly call ~eglot~ (only need to do so once or twice per Emacs session).  More info
  on why ~eglot-ensure~ is not recommended:
  https://lists.gnu.org/archive/html/bug-gnu-emacs/2023-01/msg00436.html

  This caused Emacs to hang when opening a Python file in a directory that was not managed by Eglot.

  Set Pyright as the LSP server for Python:

#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'eglot
    (add-to-list 'eglot-server-programs
                 '(python-ts-mode . ("pyright-langserver" "--stdio"))))
#+END_SRC

  Eglot pretty much figures out everything on its own, so no need to set up the LSP server or
  anything.  We'll just make sure that we have a venv and that ~pyright~ is installed in there.

#+BEGIN_SRC emacs-lisp
  (use-package python)

  (require 'ruff-format)

  (reformatter-define ruff-fix
    :program ruff-format-command
    :args (list "check" "--fix" "--exit-zero" "--stdin-filename" (or (buffer-file-name) input-file))
    :lighter " RuffFix"
    :group 'ruff-format)

  (defun get-packages-not-found (pkgs)
    (let ((not-found '()))
      (dolist (pkg pkgs)
        (goto-char (point-min))
        (unless (search-forward-regexp (concat "^" pkg) nil t)
          (push pkg not-found)))
      not-found))

  (defun ensure-healthy-venv ()
    (let ((py-packages
           (list
            "ruff"
            ;; "mypy"
            "pyright"
            ;; "pylsp-mypy"
            ;; "pylsp-rope"
            ;; "python-lsp-ruff"
            ;; "debugpy"
            )))
      (with-temp-buffer
        (apply 'call-process "pip" nil (current-buffer) nil (list "list"))
        (let ((not-found (get-packages-not-found py-packages)))
          (cond (not-found
                 (message "Installing missing packages: %s" (string-join not-found ", "))
                 (apply 'call-process "pip" nil nil nil (cons "install" not-found)))
                (t (message "All packages found")))))))

  (defun find-venv (path)
    (or (let ((top-level (locate-dominating-file (buffer-file-name) ".venv")))
          (when top-level
            (concat top-level ".venv")))
        ;; TODO use a glob here? better integration with pants
        (let* ((common-suffixes '("dist/export/python/virtualenvs/python-default/3.11.11" ".venv" "venv"))
               (top-level (locate-dominating-file
                           (buffer-file-name)
                           (lambda (path)
                             (and (directory-name-p path)
                                  (cl-some (lambda (suffix)
                                             (file-exists-p (concat path suffix)))
                                           common-suffixes))
                             ))))
          (when top-level
            (message "Found venv at %s" top-level)
            (cl-some (lambda (suffix) (let ((path (concat top-level suffix))) (when (file-exists-p path) path)))
                     common-suffixes)))))

  (defun find-and-activate-venv ()
    ;; activate pyvenv tracking mode
    (let ((current-path (buffer-file-name)))
      (when current-path
        (let ((venv-path (find-venv current-path)))
          (if (null venv-path)
              (message "No venv found")
            (message "Activating venv at %s" venv-path)
            (pyvenv-activate venv-path)
            (pyvenv-tracking-mode 1)
            (make-local-variable 'pyvenv-activate)
            (setq pyvenv-activate venv-path)

            ;; make sure venv is properly set up
            (message "Ensuring healthy venv")
            (ensure-healthy-venv)))))

    ;; Auto-format code on save according to ruff.  Note: there's no
    ;; command in ruff to both format and fix linting issues.  See:
    ;; https://github.com/astral-sh/ruff/issues/8232
    ;; TODO figure out how to have `eglot-format' do this automatically
    (ruff-fix-on-save-mode 1)
    (ruff-format-on-save-mode 1)
    )

  (add-hook 'python-ts-mode-hook 'find-and-activate-venv)

  ;; (setenv "PYLSP_MYPY_ALLOW_DANGEROUS_CODE_EXECUTION" "1")
#+END_SRC

** Electric pairs

#+BEGIN_SRC emacs-lisp
  (add-hook 'python-ts-mode-hook 'electric-pair-mode)
#+END_SRC


** Keybindings

  Use ~s-<left>~ and ~s-<right>~ to indent / dedent regions.  This is usually
  bound to beggining / ending of lie, but I am more used to ~C-e~ / ~C-a~ for
  that.

#+BEGIN_SRC emacs-lisp
  (define-key python-ts-mode-map (kbd "s-<left>") 'python-indent-shift-left)
  (define-key python-ts-mode-map (kbd "s-<right>") 'python-indent-shift-right)
#+END_SRC

  And ~C-c r~ to rename symbols in Python using ~eglot~:

#+BEGIN_SRC emacs-lisp
  (define-key python-ts-mode-map (kbd "C-c r") 'eglot-rename)
#+END_SRC

  Elpy-style line move.  ~transpose-lines~ leaves point at a wrong position, and doesn't support
  moving whole regions.  Note: this still doesn't work nicely when the region doesn't cover entire
  lines.

#+BEGIN_SRC emacs-lisp
  (use-package move-text :ensure t
    :bind (("M-<up>" . move-text-up)
           ("M-<down>" . move-text-down))
    :config
    (setq move-text-default-bindings nil))
#+END_SRC

* Corfu

  I use [Corfu](https://github.com/minad/corfu) as the completion UI backend.

#+BEGIN_SRC emacs-lisp
  (use-package corfu
    :custom
    (corfu-auto t)                    ;; Enable automatic completion
    (corfu-quit-no-match 'separator)  ;; Only stay alive if there is no match and `corfu-separator' has been inserted
    ;; (corfu-cycle t)                ;; Enable cycling for `corfu-next/previous'
    ;; (corfu-quit-at-boundary nil)   ;; Never quit at completion boundary
    ;; (corfu-preview-current nil)    ;; Disable current candidate preview
    ;; (corfu-preselect 'prompt)      ;; Preselect the prompt
    ;; (corfu-on-exact-match nil)     ;; Configure handling of exact matches
    

    :init
    (global-corfu-mode)

    ;; Enable optional extension modes:
    (corfu-history-mode)
    (corfu-popupinfo-mode)
    )

  ;; A few more useful configurations...
  (use-package emacs
    :custom
    ;; TAB cycle if there are only few candidates
    ;; (completion-cycle-threshold 3)

    ;; Enable indentation+completion using the TAB key.
    ;; `completion-at-point' is often bound to M-TAB.
    (tab-always-indent 'complete)

    ;; Emacs 30 and newer: Disable Ispell completion function.
    ;; Try `cape-dict' as an alternative.
    (text-mode-ispell-word-completion nil)

    ;; Hide commands in M-x which do not apply to the current mode.  Corfu
    ;; commands are hidden, since they are not used via M-x. This setting is
    ;; useful beyond Corfu.
    (read-extended-command-predicate #'command-completion-default-include-p))
#+END_SRC

* Projectile

#+BEGIN_SRC emacs-lisp
  (require 'projectile)

  (projectile-global-mode)

  (global-set-key (kbd "C-c p s") 'projectile-switch-project)
  (global-set-key (kbd "C-c f") 'projectile-find-file)
#+END_SRC

* YAML mode

#+BEGIN_SRC emacs-lisp
  (require 'yaml-mode)
  (add-to-list 'auto-mode-alist '("\\.yml\\'" . yaml-mode))
#+END_SRC

* Typescript

#+BEGIN_SRC emacs-lisp
  (push "/Users/rudiaraujo/.nvm/versions/node/v22.15.0/bin" exec-path)

  (require 'typescript-mode)
  (add-to-list 'auto-mode-alist '("\\.ts\\'" . typescript-mode))
  (add-to-list 'auto-mode-alist '("\\.tsx\\'" . typescript-mode))

  (eval-after-load 'typescript-mode
    '(add-hook 'typescript-mode-hook
               (lambda ()
                 (setq typescript-indent-level 2)
                 (add-hook 'after-save-hook 'eslint-fix nil t))))
#+END_SRC

* JSON

  Plus, let's bind ~json-pretty-print-buffer~ to a key combination:

#+BEGIN_SRC emacs-lisp
  (add-hook 'json-mode-hook
            (lambda ()
              (local-set-key (kbd "C-M-q") 'json-pretty-print-buffer)
              (make-local-variable 'js-indent-level)
              (setq js-indent-level 2)))
#+END_SRC

* Copilot

#+BEGIN_SRC emacs-lisp
  (use-package copilot
    :vc (:url "https://github.com/copilot-emacs/copilot.el"
              :rev :newest
              :branch "main")
    :hook ((prog-mode . copilot-mode)
           (text-mode . copilot-mode)
           (copilot-mode . (lambda ()
                             (setq-local copilot--indent-warning-printed-p t))))
    :bind (:map copilot-completion-map
                ("Â§" . 'copilot-accept-completion)
                ("s-Â§" . 'copilot-accept-completion-by-word)
                ("M-Â§" . 'copilot-next-completion)))
#+END_SRC

* Exec path from shell

  Copy env vars from shell.

#+BEGIN_SRC emacs-lisp
  (when (memq window-system '(mac ns x))
    (exec-path-from-shell-initialize))
#+END_SRC

* Line numbers

  Enable line numbers globally:

#+BEGIN_SRC emacs-lisp
  (global-display-line-numbers-mode)
#+END_SRC

* Treemacs

  This binding is used locally in some modes, but that is not a problem.  I
  don't use it so much anyway.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c t") 'treemacs)
#+END_SRC

  The mode line is useless in ~treemacs~, let's get rid of it:

#+BEGIN_SRC emacs-lisp
  (add-hook 'treemacs-mode-hook 
            (lambda () 
              (setq mode-line-format nil)
              (face-remap-add-relative 'default :family "Helvetica Neue")
              (display-line-numbers-mode -1)))
#+END_SRC

  I want to see the ~treemacs~ buffer by default:

#+BEGIN_SRC emacs-lisp
  (treemacs)
#+END_SRC

  Line folding doesn't work very well in ~treemacs~ (and it's ugly):

#+BEGIN_SRC emacs-lisp
  (toggle-truncate-lines 1)
#+END_SRC

* Pants

  Enable Python mode on Pants BUILD files.  This of course shows a lot of errors related to unknown
  functions, etc., but still nice to do stuff like linting/auto-fixing, and syntax checking.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist '("BUILD\\'" . python-mode))
#+END_SRC

* Find on Github

  Open the browser with the currently visited file on GitHub.

#+BEGIN_SRC emacs-lisp
  (require 'find-on-github)
  (global-set-key (kbd "M-g b") 'browse-on-github)
#+END_SRC

* gptel - Large Language Model Interface for Emacs

  GPTel is an Emacs package that provides interfaces to interact with large
  language models directly within Emacs.  The following configuration sets up
  GPTel to use Anthropic's Claude model.

#+BEGIN_SRC emacs-lisp
  (straight-use-package 'gptel)

  (defun anthropic-key () (getenv "ANTHROPIC_API_KEY"))

  (setq gptel-backend
        (gptel-make-anthropic "Claude" :stream t :key 'anthropic-key))

  (global-set-key (kbd "C-c l") 'gptel-send)
  (global-set-key (kbd "C-c w") 'gptel-rewrite)
  (global-set-key (kbd "C-c c") 'gptel)
  (global-set-key (kbd "C-c q") 'gptel-quick) ; manually installed
#+END_SRC

* Emacs Application Framework

  The Emacs Application Framework (EAF) enhances Emacs by embedding modern graphical applications
  within the text editor through Python and PyQt technology. This extension allows users to browse
  the web, view PDFs, manipulate images, and play videos directly in Emacs while maintaining its
  keyboard-centric workflow.  Unfortunately, doesn't work super well in Mac OS (slow and doesn't
  work well in fullscreen).

#+BEGIN_SRC emacs-lisp
  (use-package eaf
    :load-path "~/.emacs.d/site-lisp/emacs-application-framework"
    :custom
    ;; See https://github.com/emacs-eaf/emacs-application-framework/wiki/Customization
    (eaf-browser-continue-where-left-off t)
    (eaf-browser-enable-adblocker t))

  (require 'eaf-markdown-previewer)
#+END_SRC
